from telegram import Update
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, MessageHandler, filters, ContextTypes
from .config import TelegramConfig
from .messages import MessageTemplates
from ..database.deps import SessionDep
from ..models.beats import BeatModel, StatusType
from sqlalchemy import select
import asyncio
from contextlib import asynccontextmanager

class TelegramBotHandlers:
    def __init__(self, session_factory):
        self.session_factory = session_factory
        self.pending_rejections = {}  # user_id -> beat_id

    @asynccontextmanager
    async def get_session(self):
        async with self.session_factory() as session:
            try:
                yield session
            except Exception:
                await session.rollback()
                raise

    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        await update.message.reply_text(
            "–ü—Ä–∏–≤–µ—Ç! –Ø –±–æ—Ç –¥–ª—è –º–æ–¥–µ—Ä–∞—Ü–∏–∏ –±–∏—Ç–æ–≤ –Ω–∞ –ø–ª–∞—Ç—Ñ–æ—Ä–º–µ Beatok.\n"
            "–Ø –±—É–¥—É –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –Ω–æ–≤—ã—Ö –±–∏—Ç–∞—Ö –¥–ª—è –º–æ–¥–µ—Ä–∞—Ü–∏–∏."
        )

    async def handle_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        query = update.callback_query
        await query.answer()

        callback_data = query.data

        if callback_data.startswith("approve_beat_"):
            beat_id = int(callback_data.split("_")[-1])
            await self._handle_beat_approval(beat_id, query)
        elif callback_data.startswith("reject_beat_"):
            beat_id = int(callback_data.split("_")[-1])
            await self._handle_beat_rejection(beat_id, query)

    async def _handle_beat_approval(self, beat_id: int, query):
        async with self.get_session() as session:
            try:
                result = await session.execute(
                    select(BeatModel).where(BeatModel.id == beat_id)
                )
                beat = result.scalar_one_or_none()

                if not beat:
                    await query.edit_message_text("–ë–∏—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω.")
                    return

                if beat.status != StatusType.MODERATED:
                    await query.edit_message_text("–ë–∏—Ç —É–∂–µ –±—ã–ª –æ–±—Ä–∞–±–æ—Ç–∞–Ω.")
                    return

                beat.status = StatusType.AVAILABLE
                await session.commit()

                await query.edit_message_text(
                    f"‚úÖ –ë–∏—Ç '{beat.name}' (ID: {beat.id}) –æ–¥–æ–±—Ä–µ–Ω –∏ –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω."
                )
            except Exception as e:
                await session.rollback()
                await query.edit_message_text(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–¥–æ–±—Ä–µ–Ω–∏–∏ –±–∏—Ç–∞: {str(e)}")
                print(f"Error approving beat {beat_id}: {e}")

    async def _handle_beat_rejection(self, beat_id: int, query):
        async with self.get_session() as session:
            try:
                result = await session.execute(
                    select(BeatModel).where(BeatModel.id == beat_id)
                )
                beat = result.scalar_one_or_none()

                if not beat:
                    await query.edit_message_text("–ë–∏—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω.")
                    return

                if beat.status != StatusType.MODERATED:
                    await query.edit_message_text("–ë–∏—Ç —É–∂–µ –±—ã–ª –æ–±—Ä–∞–±–æ—Ç–∞–Ω.")
                    return

                # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –æ–∂–∏–¥–∞–Ω–∏—è –ø—Ä–∏—á–∏–Ω—ã –æ—Ç–∫–∞–∑–∞
                user_id = query.from_user.id
                self.pending_rejections[user_id] = beat_id

                await query.edit_message_text(
                    f"‚ùå –í—ã –æ—Ç–∫–ª–æ–Ω–∏–ª–∏ –±–∏—Ç '{beat.name}' (ID: {beat.id}).\n\n"
                    f"üìù –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –ø—Ä–∏—á–∏–Ω—É –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏—è –≤ —Å–ª–µ–¥—É—é—â–µ–º —Å–æ–æ–±—â–µ–Ω–∏–∏."
                )
            except Exception as e:
                await session.rollback()
                await query.edit_message_text(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–∏ –±–∏—Ç–∞: {str(e)}")
                print(f"Error rejecting beat {beat_id}: {e}")

    async def handle_text_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        message_text = update.message.text

        if user_id in self.pending_rejections:
            beat_id = self.pending_rejections[user_id]
            del self.pending_rejections[user_id]

            async with self.get_session() as session:
                try:
                    result = await session.execute(
                        select(BeatModel).where(BeatModel.id == beat_id)
                    )
                    beat = result.scalar_one_or_none()

                    if not beat:
                        await update.message.reply_text("–ë–∏—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω.")
                        return

                    if beat.status != StatusType.MODERATED:
                        await update.message.reply_text("–ë–∏—Ç —É–∂–µ –±—ã–ª –æ–±—Ä–∞–±–æ—Ç–∞–Ω.")
                        return

                    beat.status = StatusType.DENIED
                    beat.rejection_reason = message_text
                    await session.commit()

                    await update.message.reply_text(
                        f"‚úÖ –ë–∏—Ç '{beat.name}' (ID: {beat.id}) –æ—Ç–∫–ª–æ–Ω–µ–Ω.\n"
                        f"üìù –ü—Ä–∏—á–∏–Ω–∞: {message_text}"
                    )
                except Exception as e:
                    await session.rollback()
                    await update.message.reply_text(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –ø—Ä–∏—á–∏–Ω—ã –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏—è: {str(e)}")
                    print(f"Error saving rejection reason for beat {beat_id}: {e}")
        else:
            await update.message.reply_text("–Ø –Ω–µ –æ–∂–∏–¥–∞—é –ø—Ä–∏—á–∏–Ω—É –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏—è. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –¥–ª—è –º–æ–¥–µ—Ä–∞—Ü–∏–∏ –±–∏—Ç–æ–≤.")

def setup_bot_handlers(application: Application, session_factory):
    handlers = TelegramBotHandlers(session_factory)

    application.add_handler(CommandHandler("start", handlers.start_command))
    application.add_handler(CallbackQueryHandler(handlers.handle_callback))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handlers.handle_text_message))

    return application
